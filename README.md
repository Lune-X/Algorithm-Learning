# 					Algorithm Learning outcomes

## Day1: Bubble Sort——冒泡排序

双重循环控制数组遍历

**外层循环：**

外层循环的条件是：

```
for (int i = 0; i < array.length - 1; i++) {
```

对于长度为 8 的数组，`array.length - 1` 就是 `7`，所以 `i` 的取值范围是 `0` 到 `6`。外层循环控制着执行排序的轮数，最多需要 `array.length - 1` 次轮次排序。

**内层循环：**

内层循环的条件是：

```
for (int j = 0; j < array.length - 1 - i; j++) {
```

`j` 从 `0` 开始，一直到 `array.length - 1 - i`，这个条件控制了相邻元素的比较范围。每一轮都会把一个最大的元素“冒泡”到数组的末尾，因此，随着 `i` 的增加，内层循环的比较范围逐渐缩小，因为数组末尾已经排好序的部分不再需要比较。



### **时间复杂度：**

- **最坏情况**：O(n²)（完全逆序）
- **最好情况**：O(n)（已经有序）
- **平均情况**：O(n²)（随机顺序）



### **空间复杂度**： 

O(1)



## Day2:Inert Sort——插入排序

插入排序的工作原理是通过逐步将未排序部分的元素插入到已排序部分中，从而逐渐构建一个有序的数组。它假定数组的第一个元素是排序好的，然后从第二个元素开始，将每个元素依次插入到已经排序的数组部分中。插入时，依次比较当前元素和已排序部分的元素，并将比当前元素大的元素向右移动，腾出位置给当前元素。



### **时间复杂度：**

- **最坏情况**：O(n²)（例如，输入数组是逆序的）。
- **最好情况**：O(n)（例如，输入数组已经是有序的）。
- **平均情况**：O(n²)。

由于插入排序需要不断地将元素插入到已排序部分中，最坏的情况下每次插入需要移动多个元素，因此时间复杂度是 O(n²)。不过，如果数组接近有序，它的效率会比较高，接近 O(n)。



### **空间复杂度**： 

O(1)



## Day3:Selection Sort ——选择排序

每次从未排序部分中选出最小（或最大）的元素，放到已排序部分的末尾，依次进行，直到整个数组有序。



### 时间复杂度：

O(n²) 因为存在两层嵌套循环。



### 空间复杂度：

O(1) 

选择排序是 **原地排序算法**，即除了少量的临时变量外，它不需要额外的存储空间。



## Day4:Merge Sort——归并排序

归并排序是一种基于 **分治法** 的排序算法。它通过将数组递归地分成两半，分别进行排序，然后再将排序好的部分合并成一个有序的数组。



### 归并排序的基本步骤：

1. **分割（Divide）**：将数组从中间分成两半，递归地对子数组进行排序。
2. **合并（Conquer）**：将两个已经排好序的子数组合并成一个有序的数组。



### 归并排序的特点：

- **递归思想**：数组被不断地划分，直到每个子数组只包含一个元素（一个元素的数组是天然有序的）。
- **合并阶段**：通过一个辅助数组，将两个有序的子数组合并成一个有序的数组。



### 时间复杂度：

归并排序的时间复杂度是 O(n log n)。

- **分割阶段**：数组每次都被划分为两部分，划分的深度为 `log n`，因为每次递归将问题规模减半。
- **合并阶段**：每次合并时，需要遍历整个数组，这需要 O(n) 的时间。
- 因此，总的时间复杂度是 O(n log n)。



### 空间复杂度：

归并排序的空间复杂度是 O(n)，因为每次合并时都需要借助额外的数组来存储左右子数组。

- **递归调用栈**：递归的深度是 `log n`，因此栈空间为 O(log n)。
- **辅助数组**：合并时需要临时数组存储左右子数组，辅助数组的空间复杂度是 O(n)。

因此，总的空间复杂度是 O(n)。



### 归并排序的优缺点：

- **优点**：
  - 稳定排序：相同元素的相对顺序不会改变。
  - 时间复杂度始终为 O(n log n)，不受数组初始状态的影响。
  - 适合处理大规模数据。
- **缺点**：
  - 需要额外的空间，空间复杂度为 O(n)，在处理大数据时可能会消耗较多内存。